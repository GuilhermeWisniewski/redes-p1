#!/usr/bin/env python3
import asyncio
from tcp import Servidor
import re

apelido_map = {}


def validar_nome(nome):
    return re.match(br'^[a-zA-Z][a-zA-Z0-9_-]*$', nome) is not None


def sair(conexao):
    print(conexao, 'conexão fechada')
    conexao.fechar()

def dados_recebidos(conexao, dados):
    
    conexao.buffer = []
    conexao.buffer.append(dados)  # Adicionando os dados à lista de buffer

    print(conexao.buffer)

    comando_final = None
    if conexao.buffer[-1] == b'\n':  
        comando_final = b''.join(conexao.buffer)  # Concatenando todos os dados em uma única sequência de bytes
        print(comando_final)

# Verificando e processando o comando final
    if comando_final == b'':
        sair(conexao)
    elif comando_final.startswith(b'PING'):
        mensagem_ping(conexao, comando_final)
    elif comando_final.startswith(b'NICK'):
        mensagem_nick(conexao, comando_final)
    elif comando_final.startswith(b'PRIVMSG'):
        mensagem_privmsg(conexao, comando_final)
    elif comando_final.startswith(b'JOIN'):
        mensagem_join(conexao, comando_final)
    elif comando_final.startswith(b'PART'):
        mensagem_part(conexao, comando_final)



    """
    # Criar o buffer
    #conexao.buffer = b''
    #conexao.buffer += dados
    conexao.buffer = dados

    comandos = conexao.buffer#.split(b' ', 1)

    
    i = 0
    while i < len(comandos):
        comando = comandos[i]
        if comando == b'':
            return sair(conexao)
        if comando.startwith(b'PING'):
            mensagem_ping(conexao, comando)
        if comando.startwith(b'NICK'):
            mensagem_nick(conexao, comando)
        if comando.startwith(b'PRIVMSG'):
            mensagem_privmsg(conexao, comando)
        if comando.startwith(b'JOIN'):
            mensagem_join(conexao, comando)
        if comando.startwith(b'PART'):
            mensagem_part(conexao, comando)

        i += 1
    conexao.buffer = comandos[-1] if comandos[-1] else b''
    mensagem_ping(conexao, comandos)

    if conexao.buffer == b'':
        return sair(conexao)

    print(conexao, dados)

    """
def mensagem_ping(conexao, comando):
    mensagem_server = b':server PONG server :' + comando.split(b' ', 1)[1]
    conexao.enviar(mensagem_server)

def mensagem_nick(conexao, comando):
    apelido = comando.split(b' ', 1)[1].split('\r\n')[0]

    # Verifica se o nome existe no apelido_map
    if apelido.lower() in apelido_map:
        mensagem_server = b':server 433 ' + conexao.apelido + b' ' + apelido + b' :Nickname is already in use' + b'\r\n'
        conexao.enviar(mensagem_server)
        return
    
    if (conexao.apelido == b'*'):
        if validar_nome(apelido):
            apelido_map[apelido.lower] = conexao
            conexao.apelido = apelido

            mensagem_server = b':server 001 ' + apelido + b' :Welcome' + b'\r\n'
            conexao.enviar(mensagem_server)

            mensagem_server = b':server 422 ' + apelido + b' :MOTD File is missing' + b'\r\n'
            conexao.enviar(mensagem_server)
            

        else:
            mensagem_server = b':server 432 ' + b'* ' + apelido + b' :Erroneous nickname' + b'\r\n'
            conexao.enviar(mensagem_server)


def mensagem_privmsg(conexao, comando):
    # Dividindo os dados recebidos
    _, destinatario, conteudo = comando.strip(b'\r\n').split(b' ', 2)
    conteudo = conteudo[1:]

    # Verificando se o destinatário está mapeado
    if destinatario.lower() not in apelido_map:
        return

    # Obtendo a conexão de destino com base no apelido
    conexao_destino = apelido_map[destinatario.lower()]

    # Criando a mensagem para enviar ao servidor
    mensagem_server = b':' + conexao.apelido + b' PRIVMSG ' + destinatario + b' :' + conteudo + b'\r\n'
    conexao_destino.enviar(mensagem_server)



def mensagem_join(conexao, comando):
    # Recortando os dados recebidos
    _, nome_canal = comando.strip(b'\r\n').split(b' ', 1)

    # Verificando se o canal tem um nome válido
    if nome_canal[0] != b'#' and not validar_nome(nome_canal[1:]):
        mensagem_server = b':server 403 ' + nome_canal + b' :No such channel' + b'\r\n'
        conexao.enviar(mensagem_server)
        return

    # Criando ou recuperando o canal desejado
    if nome_canal.lower() not in apelido_map:
        canal = Canal(nome_canal)
        apelido_map[ nome_canal.lower() ] = canal
    else:
        canal = apelido_map[ nome_canal.lower() ]

    conexao.canais.append(canal)
    canal.join_membro(conexao)

def mensagem_part(conexao, comando):
    # Recortando os dados recebidos
    _, nome_canal = dados.strip(b'\r\n').split(b' ', 1)

    # Ignorando informações que vierem depois do nome do canal
    if nome_canal.find(b' ') != -1:
        nome_canal, _ = nome_canal.split(b' ', 1)

    # Verificando se o canal tem um nome válido
    if nome_canal[0] != b'#' and not validar_nome(nome_canal[1:]):
        mensagem_server = b':server 403 ' + nome_canal + b' :No such channel' + b'\r\n'
        conexao.enviar(mensagem_server)
        return

    # Recuperando o canal desejado
    if nome_canal.lower() not in apelido_map:
        canal = Canal(nome_canal)
        apelido_map[ nome_canal.lower() ] = canal
    else:
        canal = apelido_map[ nome_canal.lower() ]

    conexao.canais.remove(canal)
    canal.part_membro(conexao)


def conexao_aceita(conexao):
    print(conexao, 'nova conexão')
    conexao.registrar_recebedor(dados_recebidos)




servidor = Servidor(6667)
servidor.registrar_monitor_de_conexoes_aceitas(conexao_aceita)
asyncio.get_event_loop().run_forever()