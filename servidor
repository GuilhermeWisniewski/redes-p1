#!/usr/bin/env python3
import asyncio
from tcp import Servidor
import re

#apelido_map = {}
#conexao.apelidosCadastrados = []

def validar_nome(nome):
    return re.match(br'^[a-zA-Z][a-zA-Z0-9_-]*$', nome) is not None


def sair(conexao):
    print(conexao, 'conexão fechada')
    conexao.fechar()


def dados_recebidos(conexao, dados):

    if dados == b'':
        return sair(conexao)
    
    # Concatenar os dados recebidos em cada recebimento
    conexao.buffer += dados

    # Obs: So entra nesse while se ja tiver pelo menos 1 comando completo
    while b'\r\n' in conexao.buffer:
        comandoCompleto = conexao.buffer.split(b'\r\n', 1)
        primeiroComando = comandoCompleto[0]
        conexao.buffer = comandoCompleto[1] # Devolver o resto do comando para o buffer

        #primeiroComando += b'\r\n' # Devolver a finalizacao para o primeiro comando
        primeiroComando = primeiroComando.split(b' ', 1)
        tipoComando = primeiroComando[0]
        mensagem = primeiroComando[1]

        # Executando o comando com base em seu tipo
        if tipoComando == b'':
            return sair(conexao)

        elif tipoComando == (b'PING'):
            mensagem_ping(conexao, mensagem)
        
        elif tipoComando == (b'NICK'):
            mensagem_nick(conexao, mensagem)
        """
        elif comando.startwith(b'PRIVMSG'):
            mensagem_privmsg(conexao, comando)

        elif comando.startwith(b'JOIN'):
            mensagem_join(conexao, comando)

        elif comando.startwith(b'PART'):
            mensagem_part(conexao, comando)
        """
    if dados == b'':
        return sair(conexao)

    print(conexao, dados)
    

def conexao_aceita(conexao):
    print(conexao, 'nova conexão')
    conexao.registrar_recebedor(dados_recebidos)

    # Criando os atributos vazios do objeto conexao
    conexao.buffer = b''
    conexao.apelidoAtual = b'*'
    # Obs: talves esse "apelidosCadastrados" vai precisar ser global para ele manter
    #      os dados salvos mesmo quando abrir e fechar a conexao (a conexao eh aberta e
    #      fechada em cada um dos 10 teste)
    conexao.apelidosCadastrados = []


def mensagem_ping(conexao, mensagem):
    mensagem_server = (b':server PONG server :' + mensagem + b'\r\n')
    conexao.enviar(mensagem_server)

def mensagem_nick(conexao, apelidoDesejado):

    # Verificando se o apelido desejado esta dentro dos conformes
    if apelidoDesejado.lower() in conexao.apelidosCadastrados:  # apelido ja esta sendo usado?
        apelidoEhRepetido = True
    else: 
        apelidoEhRepetido = False
    
    if apelidoEhRepetido:
        mensagem_server = b':server 433 ' + conexao.apelidoAtual + b' ' + apelidoDesejado + b' :Nickname is already in use' + b'\r\n'
        conexao.enviar(mensagem_server)
        return

    apelidoFoiValidado = validar_nome(apelidoDesejado) # caracteres do apelido estao ok?
    # Se o usuario vai logar na primeira vez
    if (conexao.apelidoAtual == b'*'):
        if apelidoFoiValidado: # Se o primeiro apelido estiver dentro dos conformes
            conexao.apelidoAtual = apelidoDesejado
            conexao.apelidosCadastrados.append(apelidoDesejado)

            mensagem_server = b':server 001 ' + apelidoDesejado + b' :Welcome' + b'\r\n'
            conexao.enviar(mensagem_server)

            mensagem_server = b':server 422 ' + apelidoDesejado + b' :MOTD File is missing' + b'\r\n'
            conexao.enviar(mensagem_server)
            
        else: # Se o primeiro apelido tiver alguma irregularidade
            mensagem_server = b':server 432 * '  + apelidoDesejado + b' :Erroneous nickname' + b'\r\n'
            conexao.enviar(mensagem_server)

    else: # Se for mudar de apelido
        if apelidoFoiValidado: # Se o novo apelido estiver sem irregularidades
            mensagem_server = conexao.apelidoAtual + b' NICK ' + apelidoDesejado
            conexao.apelidosCadastrados.append(apelidoDesejado)
            conexao.apelidosCadastrados.remove(conexao.apelidoAtual)
            conexao.apelidoAtual = apelidoDesejado
            
        else: # Se o novo apelido tiver alguma irregularidade
            mensagem_server = b':server 432 ' + b'* ' + apelidoDesejado + b' :Erroneous nickname' + b'\r\n'
            conexao.enviar(mensagem_server)

"""
def mensagem_privmsg(conexao, comando):
    # Dividindo os dados recebidos
    _, destinatario, conteudo = comando.strip(b'\r\n').split(b' ', 2)
    conteudo = conteudo[1:]

    # Verificando se o destinatário está mapeado
    if destinatario.lower() not in apelido_map:
        return

    # Obtendo a conexão de destino com base no apelido
    conexao_destino = apelido_map[destinatario.lower()]

    # Criando a mensagem para enviar ao servidor
    mensagem_server = b':' + conexao.apelido + b' PRIVMSG ' + destinatario + b' :' + conteudo + b'\r\n'
    conexao_destino.enviar(mensagem_server)



def mensagem_join(conexao, comando):
    # Recortando os dados recebidos
    _, nome_canal = comando.strip(b'\r\n').split(b' ', 1)

    # Verificando se o canal tem um nome válido
    if nome_canal[0] != b'#' and not validar_nome(nome_canal[1:]):
        mensagem_server = b':server 403 ' + nome_canal + b' :No such channel' + b'\r\n'
        conexao.enviar(mensagem_server)
        return

    # Criando ou recuperando o canal desejado
    if nome_canal.lower() not in apelido_map:
        canal = Canal(nome_canal)
        apelido_map[ nome_canal.lower() ] = canal
    else:
        canal = apelido_map[ nome_canal.lower() ]

    conexao.canais.append(canal)
    canal.join_membro(conexao)

def mensagem_part(conexao, comando):
    # Recortando os dados recebidos
    _, nome_canal = dados.strip(b'\r\n').split(b' ', 1)

    # Ignorando informações que vierem depois do nome do canal
    if nome_canal.find(b' ') != -1:
        nome_canal, _ = nome_canal.split(b' ', 1)

    # Verificando se o canal tem um nome válido
    if nome_canal[0] != b'#' and not validar_nome(nome_canal[1:]):
        mensagem_server = b':server 403 ' + nome_canal + b' :No such channel' + b'\r\n'
        conexao.enviar(mensagem_server)
        return

    # Recuperando o canal desejado
    if nome_canal.lower() not in apelido_map:
        canal = Canal(nome_canal)
        apelido_map[ nome_canal.lower() ] = canal
    else:
        canal = apelido_map[ nome_canal.lower() ]

    conexao.canais.remove(canal)
    canal.part_membro(conexao)
"""

servidor = Servidor(6667)
servidor.registrar_monitor_de_conexoes_aceitas(conexao_aceita)
asyncio.get_event_loop().run_forever()